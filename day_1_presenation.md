

אז מה עשינו היום?

סדר יום:
1. קריאת השאלה והבנתה
2. החלטה על איזה מבנה נתונים נעשה,ולמה כולל סקיצות בטאבלט והרבה ציורים
3. החלטנו קודם כל לנסות לקרוא את הקובץ בלי קשר למבני נתונים רק לראות שאנחנו קוראים בצורה תקינה 
4. בשלב הזה התחלנו להתרענן באיך כותבים קוד בשפת סי
5. החלטנו להכניס סטודנט בודד לתוך מבני הנתונים ולראות כיצד זה עובד
6. רק לאחר מכן הכנסו את כל הסטודנטים לתוך העץ
7. רק אחרי שראינו שהעץ עובד, התחלנו לממש את האש מאפ
8. אחרי שהאש מאפ עבד, התחלנו עם המבנה נתונים הקטן של הממוצעים
9. אחרי שהכל עובד, התחלנו להתסכל על סעיף 2 והתפריט
10. תכננו תכנון למחר ומי עושה מה 

שלב I - קריאת המשימה והכנה עם ציורים ודוגמאות
בעצם קראנו טוב טוב את המשימה, וניסינו לחשוב איזה מבנה נתונים ישמש אותנו
על מנת באמת להגיע למצב שהרבה מהפעולות יהיו בממוצע של 
LOG(N)
בהנחה שהקלט לא מוכנס ממוין, כי אז זמן הריצה הופך
O(N) כי העץ הופך לרשימה מקשורת

בהתחלה, חשבנו לעשות עץ חיפוש בינארי, עבור כל כיתה ושכבה, אבל שיהיה ממוין לפי השם של הסטודנט עצמו
תוך המשך השרטוטים בטאבלט, הבנו שיהיה לנו בעיה עם חלק מהתנאים של שלב 2 כמו למצוא תלמידים מצטיינים ולא לפי השם.
עוד בעיה שחשבנו עלייה, זה שבמידה וצריך לחפש תלמיד רק לפי השם, נצטרך לעבור על כל העצים של כל הכיתות והשכבות, כדי למצוא אותו שם.

לכן החלטנו על גישה מעט שונה
מבנה נתונים הראשון באמת יהיה עץ חיפוש בינארי, על פי ממוצע של כל סטודנט וסטודנט, עדיין לכל כיתה בכל שכבה יש עץ משל עצמה.
ואז אמרנו, שבשביל לפתור את הבעיה של מציאת תלמיד לפי השם פרטי ומשפחה שלו, נשתמש בע ב
HASH TABLE
שהמימוש שלו כזה:
אנו יוצרים מערך של 
103K תאים 
103K - הראשוני הקרוב ביותר ל100 אלף
כדאי לפי מה שלמדנו אצל ערן, שגודל הטבלה יהיה מספר ראשוני קרוב ביותר לגודל הערכים הכולל.
בשביל לפתור את בעית הערכים כפולים, נשתמש בשרשור של מערך דינאמי של מצביעים.
בעצם כל VALUE 
הנו מצביע ישירות לאותו סטודנט שכבר הוקצה בעץ.
במידה ויש כמה, אזי יש לנו מערך עם מצביעים באותו תא INDEX במערך
על מנת שתהיה פריסת הנתונים בצורה נכונה כמה שאפשר 
על מנת שלא נקבל תא אחד מלא באיברים (רשימה מקשורת
)
השתמשנו בפונקציית האש של
דניאל ברנשטיין
שהיא ידועה ביעילות שלה להמרת מחרוזת למספרי תאים במערך
קודם כל בוחרים מספר ראשוני שהוא מפתח ההאש

```
unsigned long hash = 5381;
```

הוא מזיז 5 ביטים שמאלה את ההאש ואז מוסיף את ההאש עצמו, כלומר מכפיל ב 33 ואז מוסיף את ערך האסקי של התו הנוכחי
אנו עוברים על כל האיברים בסטרינג של השם המלא
לאחר מכן אנחנו מבצעים מודולו בגודל המערך
והמספר שיצא הנו האינדקס של התא במערך

בנוסף, רצינו לשמור ממוצעים של כל הקורסים בצורה מהירה
לכן יצרנו עוד מבנה קטן עבור כל שכבה יש מערך ממוצעים של כל הקורסים הקיימים.
אנחנו מעדכנים זאת תוך כדי ההכנסה לעץ בבנייה שלו,

במהלך כל היום, תמיד לאחר כתיבת קוד,וידאנו שכל הזכרון משוחרר בסוף התכנית כמובן באמצעות הפקודה של ה
VALGRIND
ובאמת אנחנו משחררים הכל בצורה תקינה

תוספת של יום 2 + אתמול בלילה
התחלנו לממש את הפונקציות של השלב ה2
וחוץ מהפונקצייה של ה
EXPORT 
מימשנו את כולם אולי לא בצורה הכי טובה בעולם אבל מומשו
1. הכנסה -
מקצים סטודנט, מתחילים לקרוא קלט מהמשתמש נתונים של הסטודנט, אם הוכנס נתון לא נכון כדוגמא
שם פרטי לא תקין, מספרים אורך וכו הסטודנט לא נכנס
כמובן משחררים את הקצאה
אם הכנסה הצליחה אז מוסיפים לעץ של הכיתה
מעדכנים פיונטר חדש לטבלת ההאש
ומעדכנים את מערך הממוצעים
2. מחיקה -
קודם כל משתמשת בפונקציה של חיפוש על סטודנט
מוודאים עם המשתמש שזהו אכן הסטודנט שהוא רוצה למחוק
ואז מוחקים אותו 
מהעץ
הופכים פוינטר בהאש לנאל
ומעדכנים מערך ממוצעים מחדש
3. עריכה
נתנו אפשרות לערוך טלפון וציונים
מוודאים עם המשתמש שזהו הסטודנט שהוא רוצה לערוך
שהוא מעדכן ערך, לפני העדכון בפועל בודקים שהוא תקין 
4. חיפוש לפי שם פרטי + שם משפחה
מייצר את האינדקס לפי פונקציית ההאש
מוודאים אם יש כפילות באותו אינדקס, שהשם פרטי ומשפחה אותו דבר
אם יש כפילות, אז שואלים האם זה הסטודנט הרצוי
5. מדפיסים את כולם 
6. TOP N סטודנטים
אז אחרי שדיברנו עם הבחור החדש, הבנו
